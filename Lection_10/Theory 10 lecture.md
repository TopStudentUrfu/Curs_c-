# Лекция 10: Наследование

## **1. Наследование**  
- **Определение**: Отношение между двумя классами, где один (дочерний) наследует свойства и методы другого (родительского).  
- **Доступ к членам класса**:  
  - **Закрытый (`private`) раздел родительского класса** недоступен в классе-наследнике.  
  - **Защищенный (`protected`) раздел** доступен родительскому классу и наследникам, но недоступен извне.  
- **Побочные эффекты**:  
  - Повторное использование кода через вызов открытых функций родительского класса.  
  - Совместимость интерфейсов: наследники сохраняют все открытые функции родителя.  

### **1. Определение базового класса `Fruit` (C++)**  
Класс содержит свойства цвета, веса и статуса фрукта. Пример с синтаксическими ошибками и их исправлением:  
```cpp
#include <iostream>
using namespace std;

class Fruit {// Родительский (базовый) класс "Фрукт"
private: // "Закрытые" компоненты (не доступны в унаследованных классах)
    int Color;
    double Weight;
public: // "Открытые" компоненты, определяющие интерфейс класса
    Fruit(int color) : Color(color), Weight(0.0), FruitIsGood(false) {} // Конструктор
    virtual ~Fruit() {} // Деструктор (объявлен виртуальным, чтобы обеспечить корректное уничтожение унаследованных классов)

    // Функция с реализацией
    int GetColor() const { return Color; }

    // Функция с реализацией
    double GetWeight() const { return Weight; }

    // Абстрактная функция (без реализации)
    virtual void Eat() = 0;
protected: // "Защищенные" компоненты (доступны в унаследованных классах, но не доступны внешнему наблюдателю)

    bool FruitIsGood;
};
int main()
{
    Fruit newFruit;
    Fruit newFruit2;
    cout << newFruit.GetColor() << endl; // 0
    return 0;
}
```

---

### **2. Наследование: классы `Apple`**  
Пример создания дочерних классов:  
```cpp
class Apple : public Fruit {
public:
    Apple();
};
Apple::Apple()
{
    Color = 1; //закрытая часть родительского класса(нет доступа)
    cout << "Apple color: " << GetColor() << endl;
}

class Orange : public Fruit {
public:
    Orange();
}
Apple::Apple()
{
    Color = 2; //закрытая часть родительского класса(нет доступа)
    cout << "Orange color: " << GetColor() << endl;
}
```
- Protected - доступен родительскому классу наследнику, но недоступная извне
**Побочные эффекты**:  
  - Повторное использование кода через вызов открытых функций родительского класса.  
  - Совместимость интерфейсов: наследники сохраняют все открытые функции родителя.  


---

## **2. Работа с объектами и полиморфизм**  
**Полиморфизм**  - Возможность подмены объекта родительского класса объектом наследника во время выполнения программы.  
- **Условия**:  
  - Объекты должны иметь совместный интерфейс (одинаковые методы).  
  - Реализуется через **указатели** или **ссылки** на базовый класс.  
**Пример**:  
```cpp
Fruit *pFruit = nullplt; 
```
**Создание экземпляра класса:**
```cpp
pFruit = new Apple; 
pFruit = new Orange; 
```


Динамическое создание объектов и использование виртуальных методов:  
```cpp
int main() {
    Fruit* pFruit = nullptr;
    pFruit1 = new Apple();  // Создание яблока
    cout << "Apple color: " << pFruit1->GetColor() << endl;

    pFruit2 = new Orange();  // Создание апельсина
    cout << "Orange color: " << pFruit2->GetColor() << endl;

    delete pFruit1;  // Освобождение памяти
    delete pFruit2;  // Освобождение памяти
    return 0;
}
```
---
Код:
```cpp
#include <iostream>
using namespace std;

class Fruit {// Родительский (базовый) класс "Фрукт"
private: // "Закрытые" компоненты (не доступны в унаследованных классах)
    int Color;
    double Weight;
public: // "Открытые" компоненты, определяющие интерфейс класса
    Fruit(int color) : Color(color), Weight(0.0), FruitIsGood(false) {} // Конструктор
    virtual ~Fruit() {} // Деструктор (объявлен виртуальным, чтобы обеспечить корректное уничтожение унаследованных классов)

    // Функция с реализацией
    int GetColor() const { return Color; }

    // Функция с реализацией
    double GetWeight() const { return Weight; }

    // Абстрактная функция (без реализации)
    virtual void Eat() = 0;
protected: // "Защищенные" компоненты (доступны в унаследованных классах, но не доступны внешнему наблюдателю)

    bool FruitIsGood;
};
class Apple : public Fruit {
public:
    Apple();
};
Apple::Apple()
{
    Color = 1; //закрытая часть родительского класса(нет доступа)
    cout << "Apple color: " << GetColor() << endl;
}

class Orange : public Fruit {
public:
    Orange();
}
Orange::Orange()
{
    Color = 2; //закрытая часть родительского класса(нет доступа)
    cout << "Orange color: " << GetColor() << endl;
}


int main() {
    Fruit* pFruit = nullptr;
    pFruit1 = new Apple();  // Создание яблока
    cout << "Apple color: " << pFruit1->GetColor() << endl;

    pFruit2 = new Orange();  // Создание апельсина
    cout << "Orange color: " << pFruit2->GetColor() << endl;

    delete pFruit1;  // Освобождение памяти
    delete pFruit2;  // Освобождение памяти
    return 0;
}
```
---
## **3. Виртуальные функции и абстрактные классы**  
- **Виртуальные функции**:  
  - Объявляются с ключевым словом `virtual`.  
  - Позволяют переопределение в наследниках.  
  - **Чисто виртуальная функция**: `virtual void eat() = 0;` (не имеет реализации в базовом классе).  
- **Абстрактный класс**:  
  - Содержит хотя бы одну чисто виртуальную функцию.  
  - Нельзя создать экземпляр.  
  - Используется для определения интерфейса.  
---
## **4. Абстрактные классы**
- Абстрактные классы - классы у которых отсутсвует реализация для отдлеьных функций. Создать экземпляр абстрактного класса нельзя. Абстрактные классы используются для определения интерфейса

---

## **5. Деструктор**  
- **Назначение**: Освобождение ресурсов (память, файлы и т.д.).  
- **Правило**: Деструктор базового класса **должен быть виртуальным**, чтобы корректно удалять объекты наследников через указатель на родителя.  

---

## **6. Паттерны проектирования**  
- **Определение**:  
  - Типовые решения для часто встречающихся задач в объектно-ориентированном программировании.  
  - Включают: описание задачи, мотивацию, решение, результат, рекомендации.  
- **Особенности**:  
  - **Не являются библиотеками** (это концепции, а не готовый код).  
- **Преимущества**:  
  - Повышение выразительности и краткости кода.  
  - Абстрагирование от деталей реализации.  
  - Единая терминология для разработчиков.  


## **Задание**  
Придумать семейство объектов:  
1. **Родительский объект**:  
   - Минимум 3 функции (+ конструктор, + деструктор).  
   - из них 2 функции — виртуальные.  
2. **Наследники**: 3 объекта, переопределяющие виртуальные методы.  
3. **Программа-реализацию работы**:  
   - Создать экземпляры наследников.  
   - Использовать указатель/ссылку на родительский класс для демонстрации полиморфизма.  
   - Показать работу виртуальных функций и корректное удаление объектов.  
