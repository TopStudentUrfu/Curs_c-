# Лекция 11: **Паттерн проектирования "Фабричный метод". Паттерн проектирование "Декоратор". Шаблонный класс "Стек". Шаблонный класс "Массив". Реализация паттерна "Итератор" для массива. Реализация паттерна "Итератор" для стека.**

## Паттерны проектирования
### **Фабричный метод**  
- **Задача**: Создание объектов-наследников заданного класса фруктов в разных частях программы.  
- **Суть**:  
  - Определяет интерфейс для создания объектов.  
  - Использует разные конструкторы с уникальной логикой, но производящие объекты одного типа.  
---

#### 1. **Базовый класс и иерархия наследования**
```cpp
class Fruit // Родительский (базовый) класс "Фрукт"
{
private: // "Закрытые" компоненты (не доступны в унаследованных классах)
    int Color;
    double Weight;

protected: // "Защищенные" компоненты (доступны в унаследованных классах, но не доступны внешнему наблюдателю)
    bool FruitIsGood;

public: // "Открытые" компоненты, определяющие интерфейс класса

    Fruit(int color) : Color(color), Weight(0.0), FruitIsGood(false) {} // Конструктор
    virtual ~Fruit() {} // Деструктор (объявлен виртуальным, чтобы обеспечить корректное уничтожение унаследованных классов)

    // Функция с реализацией
    int GetColor() const { return Color; }

    // Функция с реализацией
    double GetWeight() const { return Weight; }

    // Абстрактная функция (без реализации)
    virtual void Eat() = 0;
};
```
- **Абстрактный базовый класс**: Определяет общий интерфейс для всех фруктов
- **Виртуальный метод `Eat()`**: Обязателен для реализации в наследниках
- **Состояние**: 
  - `Color`/`Weight` - приватные характеристики
  - `FruitIsGood` - защищенный флаг качества

#### 2. **Конкретные реализации фруктов**
```cpp
// Яблоко
class Apple : public Fruit {
public:
    Apple() : Fruit(1) { FruitIsGood = true; }
    void Eat() override { cout << "Eating apple..." << endl; }
};

// Апельсин
class Orange : public Fruit {
public:
    Orange() : Fruit(2) { FruitIsGood = true; }
    void Eat() override { cout << "Eating orange..." << endl; }
};

// Киви
class Kiwi : public Fruit { //Добавили ещё один фрукт
public:
    Kiwi() : Fruit(1) { FruitIsGood = true; }
    void Eat() override { cout << "Eating kiwi..." << endl; }
};
```
- **Конструкторы**: Инициализируют цвет и устанавливают флаг качества
- **Полиморфизм**: Каждый класс реализует свою версию `Eat()`
---

#### 3. **Перечисление типов фруктов**
- Enum-класс(Строгие перечисления) — мощный инструмент для создания типобезопасного, самодокументирующегося кода, особенно полезный при реализации паттернов проектирования, где важна четкая идентификация типов объектов.
```cpp
enum class FruitType : int
{
    Apple = 1,
    Orange = 2,
    Kiwi = 3,

    Undefined = 0 // На всякий случай
};
```
- **Типизированное перечисление**: Обеспечивает типобезопасность
- **Числовые значения**: Связаны с пользовательским вводом
- **Undefined**: Для обработки ошибочных ситуаций

#### 4. **Фабричный метод (ядро паттерна)**
```cpp
Fruit *CreateFruit(FruitType type)
{
    Fruit *newFruit = nullptr;

    if(type == FruitType::Apple)
    {
        newFruit = new Apple;
    }
    else if(type == FruitType::Orange)
    {
        newFruit = new Orange;
    }
    else if(type == FruitType::Kiwi)
    {
        newFruit = new Kiwi;
    }

    return newFruit;
}
```
- **Единая точка создания**: Инкапсулирует логику инстанцирования
- **Возвращает базовый тип**: Позволяет работать с объектами полиморфно
- **nullptr при ошибках**: Возвращает нулевой указатель для невалидных типов
---
#### 5. **Использование в клиентском коде**
```cpp
int main() {
    // 1. Пользовательский выбор типа
    wcout << L"Какой фрукт создать (1 - яблоко, 2 - апельсин, 3 - киви)?" << endl;
    int input;
    cin >> input;
    
    // 2. Преобразование ввода в FruitType
    FruitType type = static_cast<FruitType>(input);
    
    // 3. Создание объекта через фабричный метод
    Fruit* fruit = CreateFruit(type);
    
    // 4. Работа через общий интерфейс
    if(fruit) {
        fruit->Eat();
        delete fruit; // Освобождение памяти
    }
    
    // ... остальной код
}
```


## Шаблонный класс - Стек

Шаблонный класс `StackClass` реализует структуру данных "стек" (LIFO - Last In, First Out) с возможностью работы с любыми типами данных через механизм шаблонов C++.

#### В файл header добавляем:
```h
#ifndef PatternTemplatesH
#define PatternTemplatesH

// Шаблонный класс "Стек"

const size_t MaxSize = 100;// статический массив элементов

template <typename T> // T - подставляемый тип данных
class StackClass
{
private:

    // Собственно контейнер, содержащий данные типа T
    T Items[MaxSize];

    // Индекс элемента стека, следующего за верхним
    size_t Top;

public:

    // Проверка того, является ли стек пустым
    bool IsEmpty() const { return (Top == 0); }

    // Определение размера стека
    size_t Size() const { return Top; }

    // Поместить в стек новый элемент
    void Push(T newObject) { Items[Top++] = newObject; }

    // Извлечь из списка верхний элемент
    T Pop() { return Items[--Top]; }

    // Получение элемента по индексу
    T GetElementByIndex(size_t index) const { return Items[index]; }

    // Конструктор
    StackClass() : Top(0) {}
};
```
---
#### Зачем использовать стек?

**Основные принципы стека (LIFO - Last In, First Out)**
1. **Последний пришел - первый ушел**: Элементы обрабатываются в обратном порядке их добавления
2. **Ограниченный интерфейс**: Только операции с верхним элементом (Push/Pop)
3. **Эффективность**: Все операции O(1) - постоянное время выполнения



### Использование шаблонного класса
#### Пример 1: Стек объектов (апельсины)
```cpp
StackClass<Orange> orangeStack;
for(size_t i=0; i<N; i++) {
    Orange newOrange;           // Создаем объект на стеке
    orangeStack.Push(newOrange); // Копируем в стек
}
wcout << L"Размер стека апельсинов: " << orangeStack.Size() << endl;
```
- **Особенности**:
  - Стек хранит **копии** объектов
  - При `Push` происходит копирование через оператор присваивания
  - Не требует ручного управления памятью
  - Объекты уничтожаются автоматически при разрушении стека
---
#### Пример 2: Стек указателей на фрукты
```cpp
StackClass<Fruit*> fruitStack;
for(size_t i=0; i<N; i++) {
    int fruit_num = rand()%3+1;
    FruitType type = static_cast<FruitType>(fruit_num);
    Fruit* newFruit = CreateFruit(type); // Создаем в куче
    fruitStack.Push(newFruit);           // Сохраняем указатель
}
wcout << L"Размер стека фруктов: " << fruitStack.Size() << endl;
// Извлечение и использование
while(!fruitStack.IsEmpty()) {
    Fruit* currentFruit = fruitStack.Pop();
    currentFruit->Eat();   // Полиморфный вызов
    delete currentFruit;   // Явное освобождение памяти!
}
```
- **Ключевые особенности**:
  1. **Полиморфизм**: Хранение разных типов фруктов через базовый указатель
  2. **Управление памятью**:
     - Объекты создаются в куче через `new`
     - Требуется явное удаление `delete`
     - Риск утечки памяти при неправильном использовании
  3. **Эффективность**: Копируются только указатели (4/8 байт), а не целые объекты
---
## Шаблонный класс - Массив
Инициализируем класс массивов в header
```cpp
template <typename T>
class ArrayClass
{
private:

    T Items[MaxSize];// Статический массив элементов
    size_t ArraySize;// Текущее количество элементов

public:

    void Add(T newObject) { Items[ArraySize++] = newObject; }// Добавление элемента
    size_t Size() const { return ArraySize; }// Получение размера

    // Первый вариант получения элемента по индексу (перегрузка оператора [])
    T operator[](size_t index) const { return Items[index]; }

    // Второй вариант получения элемента по индексу
    T GetElement(size_t index) const { return Items[index]; }

    ArrayClass() : ArraySize(0) {}// Конструктор
};

```
#### Зачем использовать массив?

**Основные характеристики массива:**
1. **Последовательное хранение**: Элементы хранятся в непрерывной области памяти
2. **Быстрый доступ по индексу**: O(1) время доступа к любому элементу
3. **Фиксированный размер**: Максимальный размер определен на этапе компиляции

### Пример использования с фруктами
```cpp
ArrayClass<Fruit*> fruitArray;

// Заполнение массива случайными фруктами
for(size_t i=0; i<10; i++) {
    int fruit_num = rand()%3+1; // Случайное число 1-3
    FruitType type = static_cast<FruitType>(fruit_num);
    Fruit* newFruit = CreateFruit(type); // Создаем фрукт
    fruitArray.Add(newFruit); // Добавляем в массив
}

// Доступ к элементам
for(size_t i=0; i<fruitArray.Size(); i++) {
    // Два варианта доступа:
    Fruit* fruit1 = fruitArray[i];     // Через оператор []
    Fruit* fruit2 = fruitArray.GetElement(i); // Через метод
    
    fruit1->Eat();
}
```
---
## Паттерн "Итератор" 

**Итератор** - это поведенческий паттерн проектирования, который:
1. Предоставляет единый интерфейс для последовательного доступа к элементам коллекции
2. Изолирует клиентский код от внутренней структуры данных
3. Позволяет реализовать различные алгоритмы обхода для одной коллекции 

**Варианты интерфейса**:
1. First(), Next(), IsDone(), GetCurrent()
2. hasNext(), next(), first()
3. begin(), end(), ++, *

#### Последовательность операций, которые будем использовать:
1. **First()**: Устанавливает итератор на начало коллекции (индекс 0)
2. **IsDone()**: Проверяет, достигнут ли конец коллекции
3. **GetCurrent()**: Получает текущий элемент
4. **Next()**: Перемещается к следующему элементу
5. Повтор шагов 2-4, пока IsDone() не вернет true

### Ключевые компоненты реализации
**1. Абстрактный базовый класс итератора:**
```cpp
// Шаблонный класс, реализующий паттерн "Итератор"
// (класс абстрактный, так как содержит функции без реализации)

template<typename T> // T - подставляемый тип данных (элемент контейнера)
class Iterator
{
protected:
    Iterator() {}

public:
    virtual ~Iterator() {}
    virtual void First() = 0; // Спозиционироваться на начале контейнера
    virtual void Next() = 0;  // Перейти к следующему элементу
    virtual bool IsDone() const = 0;  // Проверить, достигнут ли конец
    virtual T GetCurrent() const = 0; // Получить текущий элемент
};
```
**2. Конкретная реализация для массива:**
```cpp
// Реализация паттерна "Итератор",
// предназначенная для обхода массива

template<typename T>
class ArrayIterator : public Iterator<T>
{
private:
    const ArrayClass<T> *ArrayContainer; // Указатель на массив
    size_t Pos; // Текущее положение в массиве

public:
    ArrayIterator(ArrayClass<T> *container)
    : ArrayContainer(container), Pos(0) {}

    void First() override { Pos = 0; }
    void Next() override { Pos++; }
    bool IsDone() const override { return (Pos >= ArrayContainer->Size()); }
    T GetCurrent() const override { return ArrayContainer->GetElement(Pos); }
};
```
---
###  Как это работает на примере


```cpp
// Создаем контейнер
ArrayClass<Fruit*> fruitArray;
// Заполняем массив фруктами...

// Создаем итератор для контейнера
Iterator<Fruit*> *it = new ArrayIterator<Fruit*>(&fruitArray);

// Универсальный обход коллекции
for(it->First(); !it->IsDone(); it->Next()) {
    Fruit* currentFruit = it->GetCurrent();
    currentFruit->Eat(); // Полиморфный вызов
}

delete it; // Освобождаем ресурсы
```
---
###  Зачем использовать итератор?
#### Решаемые проблемы:
1. **Декомпозиция кода**:
   - Отделяет алгоритмы обхода от структуры данных
   - Клиентский код не зависит от реализации контейнера

2. **Унификация доступа**:
   - Единый интерфейс для разных типов коллекций
   - Можно писать универсальные функции обработки:
   ```cpp
   void ProcessContainer(Iterator<T>* it) {
       for(it->First(); !it->IsDone(); it->Next()) {
           // Обработка элемента
       }
   }
   ```
3. **Параллельные обходы**:
   - Возможность иметь несколько независимых итераторов для одной коллекции

4. **Ленивые вычисления**:
   - Элементы могут вычисляться по мере обхода

### Реальный пример из кода: EatEmAll
```cpp
void EatEmAll(Iterator<Fruit*> *it) {
    for(it->First(); !it->IsDone(); it->Next()) {
        Fruit *currentFruit = it->GetCurrent();
        currentFruit->Eat();
    }
}
```
- Работает с ЛЮБЫМ контейнером, реализующим интерфейс Iterator
- Не зависит от того, массив это, стек или связный список
---
## Задание:
1. Создать фабричный метод для создания объектов вашего семейства.
2. Создать два контейнера с различным устройством для хранения объектов вашего семейства. Внутри контейнеров могут быть: статический или динамический массив, вектор (vector) или список (list). В последнем случае произвольный доступ к элементам невозможен, обход реализуется при помощи итератора begin() - end(). Контейнеры должны иметь различный интерфейс.
3. Создать итераторы для обхода созданных вами контейнеров.
4. Наполнить контейнеры случайными объектами.
5. Продемонстрировать взаимозаменяемость контейнеров с точки зрения их последовательного обхода при помощи итераторов (над каждым объектом надо выполнить одно и то же действие).

- Полный код из лекции в файлах `main1.cpp` и `Pattern.h`
