
# Лекция 3: Указатели, Ссылки, Структуры


### **1. Работа с указателями**  
**Определение:** Указатель — переменная, хранящая адрес другой переменной в памяти.  

#### **Объявление указателей:**  
```cpp
int a = 10;
int* ptr_a = &a;  // Указатель на int, инициализирован адресом переменной a

int64_t b = 20;
int64_t* ptr_b;    // Объявление указателя
ptr_b = &b;        // Присвоение адреса переменной b
```  

**Особенности:**  
- Символ `*` используется для объявления указателя и доступа к значению по адресу (разыменование).  
- Символ `&` возвращает адрес переменной.  
- После удаления памяти (`delete`) указатель становится **висячим** (не должен использоваться).  

**Пример:**  
```cpp
cout << "Адрес a: " << uint64_t(ptr_a) << endl; // Вывод адреса в десятичном виде
cout << "Значение a: " << *ptr_a << endl;       // 10
```  

---

### **2. Указатели и массивы**  
**Связь массивов и указателей:**  
- Имя массива — указатель на его первый элемент.  
- Элементы массива хранятся в памяти последовательно.  

**Пример:**  
```cpp
int arr[5] = {1, 2, 3, 4, 5};
//имя массива - указатель на 1 элемент
cout << "Адрес первого элемента: " << uint64_t(arr) << endl;     // Адрес arr[0]
cout << "Адрес второго элемента: " << uint64_t(arr[0]) << endl; 

// Разница адресов (в байтах зависит от типа)
cout << "Разница: " << &arr[1] - &arr[0] << endl; // 1 (размер int = 4 байта, но разница в элементах)
```  

**Доступ через указатель:**  
```cpp
int* ptr = arr;
cout << *ptr << endl;    // 1 (первый элемент)
cout << *(ptr + 2) << endl; // 3 (третий элемент)
```  

---

### **3. Приведение типов**  
#### **1. Стиль C:**  
```cpp
int a = 10;
double b = (double)a;   // Явное приведение к double
```  

#### **2. Стиль C++:**  
- **`static_cast`** — безопасное приведение типов (проверка на этапе компиляции).  
```cpp
double c = static_cast<double>(a); // Аналогично (double)a
```  

- **`reinterpret_cast`** — низкоуровневое приведение (интерпретация битового представления).  
```cpp
unsigned char data[100];
int ptr_ammo  = &data[4]; //ошибка
int* ptr = reinterpret_cast<int*>(&data[4]); // Указатель на int, начиная с 4-го байта массива
```  

- **Константность:**  
```cpp
const int x = 5; 
```  

---

### **4. Динамические массивы**  
**Выделение памяти:**  
```cpp
int array_size;
cin >> array_size;
int* dynamicArray = new int[array_size]; // Динамический массив из array_size элементов
```  

**Использование:**  
```cpp
for (int i = 0; i < array_size; i++) {
    dynamicArray[i] = i;
    cout << dynamicArray[i] << " "; // 0 1 2 
}
```  

**Освобождение памяти:**  
```cpp
delete[] dynamicArray; // Обязательно для массивов!
```  

> **Замечание:** Не забывайте освобождать память. Утечки памяти — частая ошибка!

---

### **5. Ссылки**  
**Определение:** Ссылка — псевдоним существующей переменной.  

**Пример:**  
```cpp
int a = 10;
int &ref_a = a;   // Ссылка на a
ref_a = 20;       // a = 20
cout << a;        // 20
```  

#### **Ссылки в функциях:**  
- **Передача по значению**:  
```cpp
int sum_v(int v1, int v2) {
    return v1 + v2;
}

int main()
{
  int a = 2;
  int b = 3;
  cout << sum_v(a, b) << endl;
  cout << a << " " << b << endl;
}
```  
> **Замечание:** Значения передаваемые с указателями при присвоении новых значений - изменяются. Чтобы не менялись: int sum_p(const int *pv1, const int *pv2)

- **Передача по указателю**:  
```cpp
int sum_p(int *pv1, int *pv2) {
    return *pv1 + *pv2;
}
int main()
{
  int a = 2;
  int b = 3;
  cout << sum_p(&a, &b) << endl;
  cout << a << " " << b << endl;
}
```  
> **Замечание:** Значения передаваемые с указателями при присвоении новых значений - изменяются. Чтобы не менялись: int sum_p(const int *pv1, const int *pv2)

- **Передача по ссылке**:  
```cpp
int sum_r(int &rv1, int &rv2) {
    return *pv1 + *pv2;
}
int main()
{
  int a = 2;
  int b = 3;
  cout << sum_p(&a, &b) << endl;
  cout << a << " " << b << endl;
}
```  
**Константная ссылка**:
```cpp
```cpp
int sum_r(const int &rv1)
```

**Пример с массивом:**  
```cpp

int sum_a(const unsigned char *a, int array_size) {
    int res = 0;
    for (int i = 0; i < array_size; i++) {
        res += a[i];
    }
    return res;
}
int main()
{
  unsigned char bytl_array[100]:
  for (int i = 0; i < 100; i++) 
  {
        bytl_array[i] = i;
  }
  cout << sum_a(byte_array, 100); // Сумма 0..99
}
```

---

### **6. Структуры**  
**Определение:** Структура — пользовательский тип данных, объединяющий переменные разных типов.  

**Пример:**  
```cpp
struct ComplexNum {
    double real; // Поле "действительная часть"
    double imag; // Поле "мнимая часть"
};

int main() {
    ComplexNum num1 = {3.0, 4.0}; // Инициализация
    ComplexNum* ptr = &num1;      // Указатель на структуру

    cout << num1.real << " + " << num1.imag << "i" << endl; // 3 + 4i
    cout << ptr->real << " + " << ptr->imag << "i" << endl;  // Доступ через ->
}
```  

**Особенности:**  
- Структуры можно передавать в функции и возвращать.  
- Для удобства используйте `typedef`:  
```cpp
typedef unsigned char byte; // Псевдоним для типа
byte data[10];              // Аналогично unsigned char data[10]
```  

### Задание: 
1. Объявите структуру, описывающую свойства какого-нибудь знакомого вам предмета на ваш выбор: стол, ноутбук, чайник, плюшевая игрушка, апельсин... Вообще любого! Структура должна содержать описания минимум трех свойств (параметров) объекта. Например, для электрического чайника: цвет, мощность, объем, фирма-производитель, серийный номер. Как минимум одно свойство должно быть целым числом (мощность). Еще одно - уникальной текстовой строкой (серийный номер в примере выше).
2. Напишите функцию, которая принимает на вход массив описанных выше структур с использованием константного указателя (количество элементов в массиве тоже придется в функцию передать) и возвращает порядковый номер самого большого/мощного и т. д. (то есть сравнивает между собой числовые свойства объектов).
3. В основной программе (в функции main) динамически (при помощи new) объявите переменную-массив из минимум трех таких структур (это делается так же, как массив целых чисел). Заполните параметры структур созданного массива, можно прямо в исходном коде, без использования ввода из консоли. А можете и из консоли, как угодно. Для тех, кто хочет показать мне, насколько он крут - из текстового файла заполните и/или случайным образом :)
4. С использованием написанной в п. 2 функции определите порядковый номер (индекс) самого-самого объекта и выведите в консоль его уникальное текстовое свойство. Память не забудьте почистить
