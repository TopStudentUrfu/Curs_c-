# Лекция 4-1: Vector, List, Работа с файлами

## Альтернавы классическим массивам
### **1. Вектор (`vector`)**  
> **Определение:** Динамический массив из STL, автоматически управляющий памятью.  

#### **Создание вектора:**  
```cpp
#include <vector>
using namespace std;

vector<int> myArray1;          // Пустой вектор (размер = 0)
vector<int> myArray2(16);      // Вектор из 16 элементов (значения по умолчанию, для int = 0) 
vector<int> myArray3(10, 0);   // 10 элементов, [0, 0, ..., 0]
```  

**Структуры в векторе:**  
```cpp
struct Teapot {
    char Manual[2000];
};
vector<Teapot> myTeapots(100); // Вектор из 100 структур Teapot
```  

#### **Управление памятью:**  
#### **Резервирование памяти** (без изменения размера):  
- `reserve(n)` — резервирует память для n элементов, но не изменяет размер.
  ```cpp
  vector<int> myArray4;
  myArray4.reserve(1000); // Выделение памяти под 1000 элементов (size() остаётся 0)
  ```  
- `resize(n, value)` — изменяет размер вектора. Если n > size(), новые элементы инициализируются value.
#### **Изменение размера:**  
- `resize(n, value)` — изменяет размер вектора. Если n > size(), новые элементы инициализируются value.
  ```cpp
  myArray3.resize(20, 0); // Увеличивает размер до 20. Новые элементы = 0.
  ```  

#### **Доступ к элементам:**  
```cpp
cout << myArray3[2];       // Доступ по индексу (без проверки границ!)
cout << myArray3.at(2);    // С проверкой границ (кидает исключение)
size_t size = myArray3.size(); // Текущий размер вектора
```  

#### **обавление элементов в конец вектора**  
- `push_back(value)` — добавляет элемент в конец
```cpp
for (size_t i = 0; i < 10; i++) {
    myArray3.push_back(i*10);
    cout << myArray3[i+20] << endl;
}
```  

**Заполнение массива с помощью цикла**  
```cpp
for (size_t i = 0; i < myArray3.size(); i++) {
    myArray3[i] = i;
}
```  

**Преимущества:**  
- Быстрый доступ по индексу (`O(1)`).  
- Автоматическое расширение при `push_back()`.  

**Недостатки:**  
- Вставка/удаление в середине — `O(n)`.  

---

### **2. Список (`list` и `forward_list`)**  
> **Определение:**  
>- **`list`** — двусвязный список (каждый элемент хранит указатели на предыдущий и следующий).  
> - **`forward_list`** — односвязный список (только указатель на следующий элемент).  

#### **Пример использования:**  
```cpp
#include <list>
#include <forward_list>

list<int> myList;              // Пустой двусвязный список
forward_list<int> myList2;     // Пустой односвязный список

myList.push_back(10);          // Добавление в конец
myList.push_front(5);          // Добавление в начало
```  

**Особенности:**  
- Вставка/удаление в любом месте — `O(1)`, если известен итератор.  
- Нет доступа по индексу (`operator[]` отсутствует).  

**Когда использовать:**  
- Частые вставки/удаления в середине.  
- Не требуется доступ по индексу.  

---

### **3. Итераторы**  
> **Определение:** Патерн проектирования, позволяющий реализовать последовательный обход элементов контейнера без раскрытия его внутреннего устройства  

#### **Способы обхода:**  
1. **Классический подход:**  
   ```cpp
   for (vector<int>::iterator it = myArray3.begin(); it != myArray3.end(); it++) {
       cout << *it << " "; // *it — доступ к элементу
   }
   ```  

2. **Использование `auto`:**  
   ```cpp
   for (auto it = myArray3.begin(); it != myArray3.end(); ++it) {
       cout << *it << " ";
   }
   ```  

3. **Range-based for loop (C++11):**  
   ```cpp
   for (auto x : myArray3) {
       cout << x << " "; // x — копия элемента
   }

   // Для избежания копирования:
   for (const auto& x : myArray3) {
       cout << x << " "; // x — константная ссылка
   }
   ```  

**Зачем нужны итераторы:**  
- Единый интерфейс для работы с разными контейнерами.  
- Позволяют использовать алгоритмы STL (`sort`, `find` и т.д.).  

---
## Альтернавы строкам в стиле C
### **4. Строки (`std::string`)**  
**Определение:** Класс для работы со строками. Заменяет C-строки (`char*`).  

#### **Основные операции:**  
- **Инициализация:**  
  ```cpp
  string str1 = "Hello";
  string str2("World"); 
  ```  

- **Конкатенация:**  
  ```cpp
  string result = str1 + " " + str2; // "Hello World"
  str1.append("!");                  // "Hello!"
  ```  

- **Доступ к символам:**  
  ```cpp
  char c = str1[0];       // 'H' (без проверки границ)
  c = str1.at(1);         // 'e' (с проверкой)
  ```  

- **Поиск подстроки:**  
  ```cpp
  size_t pos = str1.find("lo"); // Возвращает позицию или string::npos
  ```  

- **Подстрока:**  
  ```cpp
  string sub = str1.substr(2, 3); // С позиции 2, длина 3 → "llo"
  ```  

#### **Потоки строк (`std::stringstream`):**  
```cpp
#include <sstream>
stringstream ss;
ss << "Age: " << 25 << ", Score: " << 95.5;
string info = ss.str(); // "Age: 25, Score: 95.5"
```  

**Широкие строки (`std::wstring`):**  
```cpp
wstring wideStr = L"Привет, мир!";
wcout << wideStr << endl;
```    

**Преимущества перед C-строками:**  
- Автоматическое управление памятью.  
- Безопасные операции (нет риска выхода за границы).  
- Удобные методы (`find`, `substr`, `replace` и др.).  

---
## **Итог**  
- **Вектор** — идеален для задач с частым доступом по индексу и редкими вставками в середину.  
- **Списки** — используйте при частых вставках/удалениях в произвольных местах.  
- **Итераторы** — универсальный интерфейс для работы с контейнерами.  
- **`std::string`** — безопасная и удобная замена C-строкам.  



# **Лекция 4-2: Работа с файлами**  


## **1. Основные классы для работы с файлами**  
**Определение:** В C++ работа с файлами осуществляется через классы из библиотеки `<fstream>`:  
- **`ifstream`** — чтение из файла (Input File Stream).  
- **`ofstream`** — запись в файл (Output File Stream).  
- **`fstream`** — чтение и запись (File Stream).  

#### **Режимы открытия файлов:**  
| Режим             | Описание                                                                 |
|--------------------|-------------------------------------------------------------------------|
| `ios::in`          | Открыть для чтения (по умолчанию для `ifstream`).                      |
| `ios::out`         | Открыть для записи (по умолчанию для `ofstream`).                      |
| `ios::app`         | Дописывать данные в конец файла (не перезаписывать).                   |
| `ios::binary`      | Бинарный режим (по умолчанию — текстовый).                             |
| `ios::trunc`       | Удалить содержимое файла при открытии (активно, если не указан `app`). |

---

## **2. Чтение из файла**  
#### **Пример 1: Построчное чтение (текстовый режим)**  
```cpp
#include <fstream>
#include <iostream>
using namespace std;

int main() {
    ifstream file("data.txt"); // Открыть файл для чтения
    if (!file.is_open()) {
        cerr << "Ошибка открытия файла!" << endl;
        return 1;
    }

    string line;
    while (getline(file, line)) { // Чтение строки до '\n'
        cout << line << endl;
    }

    file.close(); // Закрыть файл
    return 0;
}
```  

#### **Пример 2: Чтение всего содержимого**  
```cpp
ifstream file("data.txt");
if (file) { // Проверка открытия через оператор bool
    string content((istreambuf_iterator<char>(file)), 
                    istreambuf_iterator<char>());
    cout << content;
}
```  

---

## **3. Запись в файл**  
#### **Пример 1: Запись строк (текстовый режим)**  
```cpp
ofstream file("output.txt", ios::out | ios::trunc); // Перезаписать файл
if (file.is_open()) {
    file << "Строка 1" << endl;
    file << "Строка 2" << endl;
    file.close();
}
```  

#### **Пример 2: Дописывание в конец файла**  
```cpp
ofstream file("output.txt", ios::app); // Режим дописывания
file << "Строка 3" << endl;
```  

---

## **4. Бинарные файлы**  
**Определение:** В бинарном режиме данные записываются «как есть», без преобразований (например, перевод строки `\n` не заменяется на `\r\n`).  

#### **Пример 1: Запись структуры в бинарный файл**  
```cpp
struct Person {
    char name[50];
    int age;
};

Person person = {"Alice", 30};

ofstream file("person.bin", ios::binary);
if (file) {
    file.write(reinterpret_cast<char*>(&person), sizeof(Person));
    file.close();
}
```  

#### **Пример 2: Чтение структуры из бинарного файла**  
```cpp
ifstream file("person.bin", ios::binary);
if (file) {
    Person person;
    file.read(reinterpret_cast<char*>(&person), sizeof(Person));
    cout << "Имя: " << person.name << ", Возраст: " << person.age << endl;
}
```  

---

## **5. Обработка ошибок**  
- **Проверка открытия файла:**  
  ```cpp
  if (!file) {
      cerr << "Файл не открыт!" << endl;
      return 1;
  }
  ```  

- **Использование исключений:**  
  ```cpp
  file.exceptions(ifstream::failbit | ifstream::badbit);
  try {
      file.open("data.txt");
  } catch (const ifstream::failure& e) {
      cerr << "Ошибка: " << e.what() << endl;
  }
  ```  

---

### **6. Определение размера файла**  
Чтобы определить размер файла:  
1. Переместите указатель в конец файла (`seekg`).  
2. Считайте текущую позицию (`tellg`), которая равна размеру файла в байтах.  

#### **Пример:**  
```cpp
#include <fstream>
using namespace std;

int main() {
    ifstream file("data.bin", ios::binary | ios::ate); // ios::ate — открыть и сразу переместить указатель в конец
    if (file) {
        // Размер файла = позиция указателя (так как он в конце)
        streamsize size = file.tellg();
        cout << "Размер файла: " << size << " байт" << endl;

        // Вернуть указатель в начало для чтения
        file.seekg(0, ios::beg);
    }
    return 0;
}
```  

**Пояснение:**  
- `ios::ate` — открывает файл и сразу перемещает указатель в конец.  
- `tellg()` — возвращает текущую позицию указателя (в байтах).  
- `seekg(0, ios::beg)` — перемещает указатель в начало файла. 

## **7. Текстовый vs бинарный режим**  
| Параметр          | Текстовый режим                     | Бинарный режим                     |
|--------------------|-------------------------------------|-------------------------------------|
| **Перевод строки** | `\n` → `\r\n` (Windows)             | Без преобразований                 |
| **Типы данных**    | Текст                               | Любые данные (структуры, изображения) |
| **Скорость**       | Медленнее (из-за преобразований)    | Быстрее                            |  

---

## **8. Советы**  
1. **Всегда закрывайте файлы** — используйте `file.close()`, даже если поток разрушится сам.  
2. **Проверяйте открытие файла** — избегайте ошибок доступа.  
3. **Используйте RAII** — открывайте файлы в блоке `if`, чтобы они автоматически закрывались при выходе из области видимости.  
4. **Для больших файлов** — читайте данные блоками, а не целиком.  

---

## **Итог**  
- **Текстовые файлы** — подходят для человекочитаемых данных (логи, конфиги).  
- **Бинарные файлы** — эффективны для хранения структур и медиафайлов.  
- **Классы `<fstream>`** — предоставляют гибкий API для работы с файлами.  
- **Обработка ошибок** — обязательна для надежности программы.  

**Пример итогового кода:**  
```cpp
#include <fstream>
using namespace std;

int main() {
    // Запись в файл
    ofstream out("data.txt");
    if (out) {
        out << "Hello, File!" << endl;
    }

    // Чтение из файла
    ifstream in("data.txt");
    string line;
    while (getline(in, line)) {
        cout << line << endl;
    }

    return 0;
}
```







 


