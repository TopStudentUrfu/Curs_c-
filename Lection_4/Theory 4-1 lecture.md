# Лекция 4-1: Vector, List, Работа с файлами

## Альтернавы классическим массивам
### **1. Вектор (`vector`)**  
> **Определение:** Динамический массив из STL, автоматически управляющий памятью.  

#### **Создание вектора:**  
```cpp
#include <vector>
using namespace std;

vector<int> myArray1;          // Пустой вектор (размер = 0)
vector<int> myArray2(16);      // Вектор из 16 элементов (значения по умолчанию, для int = 0) 
vector<int> myArray3(10, 0);   // 10 элементов, [0, 0, ..., 0]
```  

**Структуры в векторе:**  
```cpp
struct Teapot {
    char Manual[2000];
};
vector<Teapot> myTeapots(100); // Вектор из 100 структур Teapot
```  

#### **Управление памятью:**  
#### **Резервирование памяти** (без изменения размера):  
- `reserve(n)` — резервирует память для n элементов, но не изменяет размер.
  ```cpp
  vector<int> myArray4;
  myArray4.reserve(1000); // Выделение памяти под 1000 элементов (size() остаётся 0)
  ```  
- `resize(n, value)` — изменяет размер вектора. Если n > size(), новые элементы инициализируются value.
#### **Изменение размера:**  
- `resize(n, value)` — изменяет размер вектора. Если n > size(), новые элементы инициализируются value.
  ```cpp
  myArray3.resize(20, 0); // Увеличивает размер до 20. Новые элементы = 0.
  ```  

#### **Доступ к элементам:**  
```cpp
cout << myArray3[2];       // Доступ по индексу (без проверки границ!)
cout << myArray3.at(2);    // С проверкой границ (кидает исключение)
size_t size = myArray3.size(); // Текущий размер вектора
```  

#### **обавление элементов в конец вектора**  
- `push_back(value)` — добавляет элемент в конец
```cpp
for (size_t i = 0; i < 10; i++) {
    myArray3.push_back(i*10);
    cout << myArray3[i+20] << endl;
}
```  

**Заполнение массива с помощью цикла**  
```cpp
for (size_t i = 0; i < myArray3.size(); i++) {
    myArray3[i] = i;
}
```  

**Преимущества:**  
- Быстрый доступ по индексу (`O(1)`).  
- Автоматическое расширение при `push_back()`.  

**Недостатки:**  
- Вставка/удаление в середине — `O(n)`.  

---

### **2. Список (`list` и `forward_list`)**  
> **Определение:**  
>- **`list`** — двусвязный список (каждый элемент хранит указатели на предыдущий и следующий).  
> - **`forward_list`** — односвязный список (только указатель на следующий элемент).  

#### **Пример использования:**  
```cpp
#include <list>
#include <forward_list>

list<int> myList;              // Пустой двусвязный список
forward_list<int> myList2;     // Пустой односвязный список

myList.push_back(10);          // Добавление в конец
myList.push_front(5);          // Добавление в начало
```  

**Особенности:**  
- Вставка/удаление в любом месте — `O(1)`, если известен итератор.  
- Нет доступа по индексу (`operator[]` отсутствует).  

**Когда использовать:**  
- Частые вставки/удаления в середине.  
- Не требуется доступ по индексу.  

---

### **3. Итераторы**  
> **Определение:** Патерн проектирования, позволяющий реализовать последовательный обход элементов контейнера без раскрытия его внутреннего устройства  

#### **Способы обхода:**  
1. **Классический подход:**  
   ```cpp
   for (vector<int>::iterator it = myArray3.begin(); it != myArray3.end(); it++) {
       cout << *it << " "; // *it — доступ к элементу
   }
   ```  

2. **Использование `auto`:**  
   ```cpp
   for (auto it = myArray3.begin(); it != myArray3.end(); ++it) {
       cout << *it << " ";
   }
   ```  

3. **Range-based for loop (C++11):**  
   ```cpp
   for (auto x : myArray3) {
       cout << x << " "; // x — копия элемента
   }

   // Для избежания копирования:
   for (const auto& x : myArray3) {
       cout << x << " "; // x — константная ссылка
   }
   ```  

**Зачем нужны итераторы:**  
- Единый интерфейс для работы с разными контейнерами.  
- Позволяют использовать алгоритмы STL (`sort`, `find` и т.д.).  

---
## Альтернавы строкам в стиле C
### **4. Строки (`std::string`)**  
**Определение:** Класс для работы со строками. Заменяет C-строки (`char*`).  

#### **Основные операции:**  
- **Инициализация:**  
  ```cpp
  string str1 = "Hello";
  string str2("World"); 
  ```  

- **Конкатенация:**  
  ```cpp
  string result = str1 + " " + str2; // "Hello World"
  str1.append("!");                  // "Hello!"
  ```  

- **Доступ к символам:**  
  ```cpp
  char c = str1[0];       // 'H' (без проверки границ)
  c = str1.at(1);         // 'e' (с проверкой)
  ```  

- **Поиск подстроки:**  
  ```cpp
  size_t pos = str1.find("lo"); // Возвращает позицию или string::npos
  ```  

- **Подстрока:**  
  ```cpp
  string sub = str1.substr(2, 3); // С позиции 2, длина 3 → "llo"
  ```  

#### **Потоки строк (`std::stringstream`):**  
```cpp
#include <sstream>
stringstream ss;
ss << "Age: " << 25 << ", Score: " << 95.5;
string info = ss.str(); // "Age: 25, Score: 95.5"
```  

**Широкие строки (`std::wstring`):**  
```cpp
wstring wideStr = L"Привет, мир!";
wcout << wideStr << endl;
```    

**Преимущества перед C-строками:**  
- Автоматическое управление памятью.  
- Безопасные операции (нет риска выхода за границы).  
- Удобные методы (`find`, `substr`, `replace` и др.).  

---
## **Итог**  
- **Вектор** — идеален для задач с частым доступом по индексу и редкими вставками в середину.  
- **Списки** — используйте при частых вставках/удалениях в произвольных местах.  
- **Итераторы** — универсальный интерфейс для работы с контейнерами.  
- **`std::string`** — безопасная и удобная замена C-строкам.  










 


