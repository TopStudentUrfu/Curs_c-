# **Лекция 4-2: Работа с файлами**  


## **1. Основные классы для работы с файлами**  
**Определение:** В C++ работа с файлами осуществляется через классы из библиотеки `<fstream>`:  
- **`ifstream`** — чтение из файла (Input File Stream).  
- **`ofstream`** — запись в файл (Output File Stream).  
- **`fstream`** — чтение и запись (File Stream).  

#### **Режимы открытия файлов:**  
| Режим             | Описание                                                                 |
|--------------------|-------------------------------------------------------------------------|
| `ios::in`          | Открыть для чтения (по умолчанию для `ifstream`).                      |
| `ios::out`         | Открыть для записи (по умолчанию для `ofstream`).                      |
| `ios::app`         | Дописывать данные в конец файла (не перезаписывать).                   |
| `ios::binary`      | Бинарный режим (по умолчанию — текстовый).                             |
| `ios::trunc`       | Удалить содержимое файла при открытии (активно, если не указан `app`). |

---

## **2. Чтение из файла**  
#### **Пример 1: Построчное чтение (текстовый режим)**  
```cpp
#include <fstream>
#include <iostream>
using namespace std;

int main() {
    setlocale(LC_ALL, "Russian");
    ifstream file("data.txt"); // Открыть файл для чтения
    if (!file.is_open()) {
        wcout << L"Ошибка открытия файла!" << endl;
        return 1;
    }

    string line;
    while (getline(file, line)) { // Чтение строки до '\n'
        cout << line << endl;
    }

    file.close(); // Закрыть файл
    return 0;
}
```  

#### **Пример 2: Чтение всего содержимого**  
```cpp
ifstream file("data.txt");
if (file) { // Проверка открытия через оператор bool
    string content((istreambuf_iterator<char>(file)), 
                    istreambuf_iterator<char>());
    cout << content;
}
```  

---

## **3. Запись в файл**  
#### **Пример 1: Запись строк (текстовый режим)**  
```cpp
ofstream file("output.txt", ios::out | ios::trunc); // Перезаписать файл
if (file.is_open()) {
    file << "Строка 1" << endl;
    file << "Строка 2" << endl;
    file.close();
}
```  

#### **Пример 2: Дописывание в конец файла**  
```cpp
ofstream file("output.txt", ios::app); // Режим дописывания
file << "Строка 3" << endl;
```  

---

## **4. Бинарные файлы**  
**Определение:** В бинарном режиме данные записываются «как есть», без преобразований (например, перевод строки `\n` не заменяется на `\r\n`).  

#### **Пример 1: Запись структуры в бинарный файл**  
```cpp
struct Person {
    char name[50];
    int age;
};

Person person = {"Alice", 30};

ofstream file("person.bin", ios::binary);
if (file) {
    file.write(reinterpret_cast<char*>(&person), sizeof(Person));
    file.close();
}
```  

#### **Пример 2: Чтение структуры из бинарного файла**  
```cpp
ifstream file("person.bin", ios::binary);
if (file) {
    Person person;
    file.read(reinterpret_cast<char*>(&person), sizeof(Person));
    cout << "Имя: " << person.name << ", Возраст: " << person.age << endl;
}
```  

---

## **5. Обработка ошибок**  
- **Проверка открытия файла:**  
  ```cpp
  if (!file) {
      cerr << "Файл не открыт!" << endl;
      return 1;
  }
  ```  

- **Использование исключений:**  
  ```cpp
  file.exceptions(ifstream::failbit | ifstream::badbit);
  try {
      file.open("data.txt");
  } catch (const ifstream::failure& e) {
      cerr << "Ошибка: " << e.what() << endl;
  }
  ```  

---

### **6. Определение размера файла**  
Чтобы определить размер файла:  
1. Переместите указатель в конец файла (`seekg`).  
2. Считайте текущую позицию (`tellg`), которая равна размеру файла в байтах.  

#### **Пример:**  
```cpp
#include <fstream>
using namespace std;

int main() {
    ifstream file("data.bin", ios::binary | ios::ate); // ios::ate — открыть и сразу переместить указатель в конец
    if (file) {
        // Размер файла = позиция указателя (так как он в конце)
        streamsize size = file.tellg();
        cout << "Размер файла: " << size << " байт" << endl;

        // Вернуть указатель в начало для чтения
        file.seekg(0, ios::beg);
    }
    return 0;
}
```  

**Пояснение:**  
- `ios::ate` — открывает файл и сразу перемещает указатель в конец.  
- `tellg()` — возвращает текущую позицию указателя (в байтах).  
- `seekg(0, ios::beg)` — перемещает указатель в начало файла. 

## **7. Текстовый vs бинарный режим**  
| Параметр          | Текстовый режим                     | Бинарный режим                     |
|--------------------|-------------------------------------|-------------------------------------|
| **Перевод строки** | `\n` → `\r\n` (Windows)             | Без преобразований                 |
| **Типы данных**    | Текст                               | Любые данные (структуры, изображения) |
| **Скорость**       | Медленнее (из-за преобразований)    | Быстрее                            |  

---

## **8. Советы**  
1. **Всегда закрывайте файлы** — используйте `file.close()`, даже если поток разрушится сам.  
2. **Проверяйте открытие файла** — избегайте ошибок доступа.  
3. **Используйте RAII** — открывайте файлы в блоке `if`, чтобы они автоматически закрывались при выходе из области видимости.  
4. **Для больших файлов** — читайте данные блоками, а не целиком.  

---

## **Итог**  
- **Текстовые файлы** — подходят для человекочитаемых данных (логи, конфиги).  
- **Бинарные файлы** — эффективны для хранения структур и медиафайлов.  
- **Классы `<fstream>`** — предоставляют гибкий API для работы с файлами.  
- **Обработка ошибок** — обязательна для надежности программы.  

**Пример итогового кода:**  
```cpp
#include <fstream>
using namespace std;

int main() {
    // Запись в файл
    ofstream out("data.txt");
    if (out) {
        out << "Hello, File!" << endl;
    }

    // Чтение из файла
    ifstream in("data.txt");
    string line;
    while (getline(in, line)) {
        cout << line << endl;
    }

    return 0;
}
```
## Задание:
1. Берем структуру, которую вы использовали в предыдущем задании. В текстовом редакторе ("Блокнот", "Notepad++") создаем текстовый файл, в каждой строчке которого описана одна такая структура. Поля структуры отделены друг от друга пробелами. Файл должен содержать описание нескольких структур.
2. Открываем файл и в цикле считываем содержимое файла в предварительно созданный вектор таких структур. Критерием окончания чтения должен выступать признак конца файла, как я на лекции показывал (функция eof).
3. Выводим содержимое полученного вектора в консоль в виде таблицы (по одному объекту в строке). Чтобы добавить отступы между полями, можно воспользоваться знаком табуляции ( cout << "\t" ). Если хотите сделать красиво, можете вертикальные палочки вставить в качестве разделителей столбцов и изучить, как ширину выводимых в поток полей менять при помощи функции std::setw(X) - примеры есть на cppreference.com
4. Выводим содержимое полученного вектора в строковый поток (std::stringstream) в "расширенном" формате: каждая строка описывает одно поле структуры и содержит название поля и его значение. Объекты отделяются друг от друга пустой строкой.
5. Содержимое полученного строкового потока надо вывести в файл. При этом файл надо открыть в двоичном режиме, а запись в него производить функцией write. На вход этой функции надо передать указатель на данные, содержащиеся в ранее сформированном строковом потоке. Я на лекции показывал, как получить доступ к связанной с потоком строке и указателю на начало этой строки. Можно в качестве промежуточного объекта использовать константную ссылку на строку.



