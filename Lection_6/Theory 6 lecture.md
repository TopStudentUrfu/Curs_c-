# **Лекция 6 - 1: Использование структур данных для работы с файлами сложного формата**

### **1. Порядок байтов (Endianness)**  
**Определение:** Порядок, в котором байты многобайтовых данных (например, `int`, `float`) хранятся в памяти или файле.  

#### **Типы порядка байтов:**  
1. **Little-endian**:  
   - Младший байт хранится по младшему адресу.  
   - Пример: число `0x12345678` → `78 56 34 12` (в памяти).  
   - Используется в x86/x64 архитектурах.  

2. **Big-endian**:  
   - Старший байт хранится по младшему адресу.  
   - Пример: число `0x12345678` → `12 34 56 78` (в памяти).  
   - Используется в сетевых протоколах (например, TCP/IP).  

---

### **2. Структура RAR-архива**
#### **Общий формат:**
```
Сигнатура (7 байт)       → "Rar!" + версия: 0x52 0x61 0x72 0x21 0x1A 0x07 0x00
[Главный заголовок]      → MAIN_HEAD (описание всего архива)
[Заголовки файлов]       → FILE_HEAD (для каждого файла в архиве)
...
[Последний заголовок]    → ENDARC_HEAD (конец архива)
```

---

### **3. Заголовки RAR (Base Header Block)**
Каждый заголовок содержит базовую структуру:
```cpp
#pragma pack(push, 1)
struct rar_header {
    uint16_t header_crc;    // Контрольная сумма заголовка
    uint8_t header_type;    // Тип заголовка (0x72-0x7b)
    uint16_t header_flags;  // Флаги (битовая маска)
    uint16_t header_size;   // Полный размер заголовка
};
#pragma pack(pop)
```

#### **Типы заголовков:**
| Значение | Тип              | Описание                          |
|----------|------------------|-----------------------------------|
| 0x72     | MARK_HEAD        | Маркер начала архива             |
| 0x73     | MAIN_HEAD        | Главный заголовок архива         |
| **0x74** | **FILE_HEAD**    | **Заголовок файла** (основной!)  |
| 0x7b     | ENDARC_HEAD      | Конец архива                     |

---

### **4. Детали FILE_HEAD**
После базового заголовка следуют специфичные для файла данные:
```cpp
struct rar_file_attributes {
    uint32_t PackSize;      // Размер сжатых данных
    uint32_t UnpSize;       // Размер несжатых данных
    uint8_t HostOS;         // Исходная ОС (0-Win, 1-Unix)
    uint32_t FileCRC;       // Контрольная сумма файла
    uint32_t FileTime;      // Время модификации (DOS-формат)
    uint8_t UnpVer;         // Минимальная версия для распаковки
    uint8_t Method;         // Метод сжатия (0x30-0x35)
    uint16_t NameSize;      // Длина имени файла
    uint32_t FileAttr;      // Атрибуты файла
    // Доп. поля при наличии флагов:
    // uint32_t HighPackSize (если LHD_LARGE)
    // uint32_t HighUnpSize  (если LHD_LARGE)
    // uint8_t Salt[8]       (если LHD_SALT)
};
```

#### **Флаги header_flags:**
| Флаг         | Значение (0x8000)       | Описание                     |
|--------------|-------------------------|------------------------------|
| LHD_LARGE    | Размер файла > 2GB      | Требует полей HighPack/Unp   |
| LHD_UNICODE  | Unicode-имя             | Имя в UTF-8                  |
| LHD_SALT     | Используется соль       | Добавляет 8-байтовый Salt    |
| LHD_EXTTIME  | Расширенное время       | Сложная структура времени    |

---

### **5. Пример RAR-файла в HEX-редакторе**
```
52 61 72 21 1A 07 00    ← Сигнатура "Rar!"+версия
CF 90 73 00 00 00 00 00 ← Базовый заголовок (header_type=0x73, MAIN_HEAD)
...                      
90 49 00 1A 15 00 00 AB ← Заголовок файла (header_type=0x74, FILE_HEAD)
37 7A 00 00 80 00 00 00 ← PackSize=0x7A37 (31,1 KB)
00 80 00 00 00 00 00 00 ← UnpSize=0x8000 (32 KB)
03 25 43 2C 7C 5F A6 4D ← FileCRC и FileTime
...                      
```
---

### **6. Алгоритм**

---

#### **1. Открытие файла**
```cpp
ifstream rar_file("Example.rar", ios::binary);
```
- **Режим `ios::binary`**: Файл открывается в бинарном режиме для точного чтения байтов.
- **Проверка открытия**:
  ```cpp
  if (rar_file.is_open()) { ... } 
  else {
      cerr << "Ошибка: файл не открыт!" << endl;
      return 1;
  }
  ```

---

#### **2. Определение размера файла**
```cpp
rar_file.seekg(0, ios::end);    // Перемещение указателя в конец
int fileSize = rar_file.tellg(); // Размер файла в байтах
rar_file.seekg(0, ios::beg);    // Возврат указателя в начало
```
---

#### **3. Выделение памяти**
```cpp
vector<char> rar_data(fileSize, 0);
```
---

#### **4. Чтение файла в память**
```cpp
rar_file.read(rar_data.data(), fileSize); // Чтение данных в вектор
```
- **`vector<char>`**: Используется для хранения бинарных данных.

---

#### **5. Инициализация указателя на структуру заголовка**  
```cpp
rar_header* p_header = reinterpret_cast<rar_header*>(&rar_data[7]);  
```  
- **Цель**: Пропуск сигнатуры RAR (7 байт) и получение доступа к первому заголовку.  
- **Детали**:  
  - `&rar_data[7]` — адрес 8-го байта в данных (после сигнатуры).  
  - `reinterpret_cast` — преобразование сырых байтов в структуру `rar_header`.  

---

#### **6. Вывод типа заголовка**  
```cpp
cout << "Header type: 0x" << hex << int(p_header->header_type) << endl;  
```  
- **Формат**: Шестнадцатеричный (`hex`).  
- **Особенности**:  
  - `header_type` — 1-байтовое значение (например, `0x74` для файла).  
  - Приведение к `int` необходимо для корректного вывода числового значения.  

---

#### **7. Вывод размера заголовка**  
```cpp
cout << "Header size: " << dec << int(p_header->header_size) << endl;  
```  
- **Формат**: Десятичный (`dec`).  
- **Особенности**:  
  - `header_size` — 2-байтовое значение (например, 20 байт).  
  - Приведение к `int` и сброс флага `hex` через `dec`.  

---

### **Итог выполнения кода**  
Пример вывода для архива с одним файлом:  
```
File size: 1024  
Header type: 0x74  
Header size: 32  
```


### **8. Работа с разными версиями RAR**
| Поле        | RAR 4.x | RAR 5.0 | Комментарий                     |
|-------------|---------|---------|----------------------------------|
| Сигнатура   | 7 байт  | 8 байт  | RAR 5: 0x52 61 72 21 1A 07 01 00|
| Шифрование  | AES-128 | AES-256 | Требует обработки флага LHD_SALT|
| Формат CRC  | 32-bit  | 32-bit  | Использует IEEE стандарт        |

---

### **9. Преобразование кодировок текста в Windows**  
Работа с различными кодировками — важная часть обработки текста, особенно при взаимодействии с файлами, сетевыми ресурсами или API. В Windows используются две основные кодировки:  
- **ANSI**: 8-битная кодовая страница (например, CP_ACP для системной кодировки, CP_UTF8 для UTF-8).  
- **Unicode (UTF-16)**: 16-битное представление символов (стандарт для Windows API).  
- **OEM-866**: кодировка для записи русского текста в 1-байтовую систему
- **CP1251_window**: 1 байтовая кодировка для кириллистических симполов


#### **1. Порядок байтов прямой и обратный**  
Для примера рассмотрим UTF-16
UTF-16 может использовать два порядка байтов: **Little-Endian (LE)** и **Big-Endian (BE)**. Это критически важно при работе с бинарными данными или файлами.


#### **BOM (Byte Order Mark)**  
Для указания порядка байтов в файле используется специальный маркер:  
- **UTF-16LE**: `FF FE` (записывается в начале файла).  
- **UTF-16BE**: `FE FF` (аналогично в начале файла).  

**Пример**:  
```hex
FF FE 41 00 42 00 → UTF-16LE: "AB"
FE FF 00 41 00 42 → UTF-16BE: "AB"
```

---

#### **Как определить порядок байтов**  
1. **Проверка BOM**:  
   - Если первые 2 байта файла: `FF FE` → UTF-16LE.  
   - Если первые 2 байта файла: `FE FF` → UTF-16BE.  

2. **Автоматическое определение**:  
   Некоторые библиотеки (например, ICU) анализируют BOM и конвертируют данные автоматически.

---

#### **Функции преобразования**  
1. **`MultiByteToWideChar`**  
   Преобразует строку из многобайтовой кодировки (ANSI, UTF-8) в Unicode (UTF-16).  

   **Синтаксис**:  
   ```cpp  
   int MultiByteToWideChar(  
       UINT CodePage,         // Кодовая страница (CP_ACP, CP_UTF8)  
       DWORD dwFlags,         // Флаги (обычно 0)  
       LPCCH lpMultiByteStr,  // Исходная строка (ANSI/UTF-8)  
       int cbMultiByte,       // Длина исходной строки (-1 для строк с нуль-терминатором)  
       LPWSTR lpWideCharStr,  // Буфер для результата (UTF-16)  
       int cchWideChar        // Размер буфера в символах  
   );  
   ```  

   **Пример**:  
   ```cpp  
   const char* ansiStr = "Пример текста";  
   int wideSize = MultiByteToWideChar(CP_UTF8, 0, ansiStr, -1, nullptr, 0);  
   wchar_t* wideStr = new wchar_t[wideSize];  
   MultiByteToWideChar(CP_UTF8, 0, ansiStr, -1, wideStr, wideSize);  
   wcout << L"Unicode строка: " << wideStr << endl;  
   delete[] wideStr;  
   ```  

2. **`WideCharToMultiByte`**  
   Преобразует строку из Unicode (UTF-16) в многобайтовую кодировку (ANSI, UTF-8).  

   **Синтаксис**:  
   ```cpp  
   int WideCharToMultiByte(  
       UINT CodePage,           // Кодовая страница  
       DWORD dwFlags,           // Флаги (обычно 0)  
       LPCWCH lpWideCharStr,    // Исходная строка (UTF-16)  
       int cchWideChar,         // Длина исходной строки (-1 для строк с нуль-терминатором)  
       LPSTR lpMultiByteStr,    // Буфер для результата (ANSI/UTF-8)  
       int cbMultiByte,         // Размер буфера в байтах  
       LPCCH lpDefaultChar,     // Замещающий символ для некорректных символов (nullptr)  
       LPBOOL lpUsedDefaultChar // Флаг использования замещающих символов (nullptr)  
   );  
   ```  

   **Пример**:  
   ```cpp  
   const wchar_t* wideStr = L"Пример текста";  
   int ansiSize = WideCharToMultiByte(CP_UTF8, 0, wideStr, -1, nullptr, 0, nullptr, nullptr);  
   char* ansiStr = new char[ansiSize];  
   WideCharToMultiByte(CP_UTF8, 0, wideStr, -1, ansiStr, ansiSize, nullptr, nullptr);  
   cout << "ANSI строка: " << ansiStr << endl;  
   delete[] ansiStr;  
   ```  

---

## **Практическое задание: Парсер оглавления RAR4**  

### **Цель**  
Разработать программу, выводящую список файлов в архиве формата **RAR4**, используя знания о работе с бинарными файлами и структурами данных.  

---

### **Требования к программе**  
1. **Чтение структуры RAR4**:  
   - Обработать сигнатуру архива (первые 7 байт).  
   - Найти все записи типа **0x74** (FILE_HEAD), содержащие информацию о файлах.  
   - Извлечь из каждой записи:  
     - Имя файла (поле `NameSize`).  
     - Размер сжатых данных (`PackSize`).  

2. **Структуры данных**:  
   - Использовать структуры для точного соответствия формату заголовков:  
     ```cpp  
     #pragma pack(push, 1)  
     struct rar_header { ... };          // Базовый заголовок  
     struct rar_header_atribut { ... };  // Атрибуты файла  
     #pragma pack(pop)  
     ```  

3. **Алгоритм**:  
   - Пропустить сигнатуру (7 байт).  
   - Перебирать заголовки, проверяя `header_type == 0x74`.  
   - Рассчитать смещение до имени файла

### **Инструменты и рекомендации**  
1. **Создание тестовых архивов**:  
   - Использовать **WinRAR** (версия с поддержкой RAR4).  
   - Имена файлов в архиве должны содержать только **латинские символы** (во избежание проблем с кодировкой).  

2. **Проверка**:  
   - Использовать HEX-редактор (например, **HxD**) для анализа структуры архива.  

3. **Система контроля версий**:  
   - Использовать **Git** с минимум **4 содержательными коммитами**, отражающими этапы разработки

**Задание направлено на закрепление навыков работы с бинарными данными, структурами и файлами.**

---
## Полный код:

```cpp
#include <iostream>
#include <fstream>
#include <vector>

#include <cstdint> // Это для использования обозначений целых чисел с указанием их размера

using namespace std;

// Установить 1-байтовое выравнивание
#pragma pack(push, 1)

// Объявить структуру
struct rar_header
{
    uint16_t header_crc;    // 2-байтовое целое без знака
    uint8_t header_type;    // 1-байтовое целое без знака 
    uint16_t header_flags;
    uint16_t header_size;

    // Дальше просто демонстрация
    // char padding[8]; // Пропуск 8 байтов (просто чтобы показать)
    // int32_t anotherInt; // Еще целое 4-байтовое число со знаком
};

// Восстановить выравнивание
#pragma pack(pop)

int main()
{
    // Открыть файл в двоичном режиме
    ifstream rar_file(L"t:\\Source\\Example.rar", ios::binary);

    // Убедиться, что открылся
    if(rar_file.is_open())
    {
        // Определить размер файла
        rar_file.seekg(0, ios::end);
        int fileSize = rar_file.tellg();
        cout << "File size: " << fileSize << endl;

        // Снова спозиционироваться в начало файла
        rar_file.seekg(0, ios::beg);

        // Выделить память
        vector<char> rar_data(fileSize, 0);

        // Считать данные
        rar_file.read(rar_data.data(), fileSize);

        // Инициализировать указатель на структуру
        // (по смещению 7, потому что надо пропустить сигнатуру длиной 7 байт)
        rar_header* p_header = reinterpret_cast<rar_header*>(&rar_data[7]);

        // rar_header* - тип переменной
        // p_header - имя переменной
        // &rar_data[7] - указатель на байт массива с индексом 7
        // reinterpret_cast<rar_header*> - приведение типа к rar_header*

        // Вывести два поля этой структуры

        // Вывод в шестнадцатеричном представлении (hex)
        cout << "Header type: 0x" << hex << int(p_header->header_type) << endl;

        // Вывод в десятичном представлении (dec)
        cout << "Header size: " << dec << int(p_header->header_size) << endl;
    }

    return 0;
}
```
# **Лекция 6 - 2: Отладка программы в Code::Blocks**
## **1. Запуск программы**  
- **Обычный запуск**:  
  Нажмите **F9** или кнопку *Build and Run* (зелёная стрелка).  
  - Программа выполняется полностью, вывод отображается в консоли.  
  - Используется для проверки итогового поведения.  

- **Запуск в режиме отладки**:  
  Нажмите **F8** или кнопку *Debug/Continue* (красная стрелка с жучком).  
  - Программа запускается под управлением отладчика.  
  - Позволяет контролировать выполнение по шагам.  

---

## **2. Вывод в консоль**  
- **Использование `cout` (C++)**:  
  ```cpp  
  cout << "Значение переменной: " << variable << endl;  
  ```  
  - Выводит промежуточные значения переменных в консоль.  
  - Помогает отслеживать состояние программы на разных этапах.  

- **Пример для проверки условия**:  
  ```cpp  
  if (x > 10) {  
      cout << "Условие выполнено! x = " << x << endl;  
  }  
  ```  

---

## **3. Интерактивный отладчик**  
- **Шаги выполнения**:  
  - **Step Into (F7)**: Войти в функцию (например, в пользовательский метод).  
  - **Step Over (F6)**: Выполнить текущую строку, не заходя в функции.  
  - **Step Out (Ctrl+F7)**: Выйти из текущей функции.  

- **Окна отладчика**:  
  - **Watch**: Просмотр значений переменных (добавьте переменные через правый клик).  
  - **Call Stack**: Отображение стека вызовов функций.  
  - **Debugging Log**: Лог выполнения программы.  

---

## **4. Точки останова (Breakpoints)**  
- **Установка точки останова**:  
  Щёлкните левой кнопкой мыши на левом поле редактора (рядом с номерами строк) или нажмите **Ctrl+F5**.  
  - Красный кружок появится на выбранной строке.  

- **Сценарий использования**:  
  1. Установите точку останова на строке, где нужно приостановить выполнение.  
  2. Запустите отладку (**F8**).  
  3. Программа остановится на указанной строке.  
  4. Используйте **Step Over** (F6) для пошагового выполнения.  

- **Пример**:  
  ```cpp  
  for (int i = 0; i < 10; i++) {  
      // Установите точку останова здесь, чтобы проверить значение 'i'  
      sum += i;  
  }  
  ```  

---

## **5. Анализ переменных**  
- **В режиме отладки**:  
  - Наведите курсор на переменную в коде — появится подсказка с её значением.  
  - Используйте окно **Watch** для отслеживания ключевых переменных.  

- **Динамическое изменение значений**:  
  В окне **Watch** можно изменить значение переменной прямо во время отладки (двойной клик по значению).  

---

**Пример отладки цикла**:  
```cpp  
for (int i = 0; i < 5; i++) {  
    // Установите точку останова здесь  
    cout << "Итерация: " << i << endl;  
    result *= i;  
}  
```  
- На каждой итерации проверяйте значение `result` через **Watch**.









