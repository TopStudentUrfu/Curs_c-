# Лекция 7: Передача аргументов из командной строки в программу. Программы и их разбор. Обощенное программирование с использованием функций. Можно ли возращать обобщщенные функции. Что будет на зачёте.

## **1. Работа с аргументами командной строки**  
Аргументы командной строки передаются в программу через параметры `main(int argc, char* argv[])`:  
- **`argv`** (argument vector) — это **массив C-строк** (массив указателей на `char`), содержащий аргументы командной строки.
- **`argc`** (argument count) — целое число, указывающее **количество элементов** в `argv`.

#### Пример базовой структуры:  
```cpp  
#include <iostream>
using namespace std;

int main(int argc, char* argv[]) { 
    cout << "Hello, World!" << endl;
    return 0;
}
```  
---
#### **Структура массива `argv`**
```plaintext
argv[0] → "название_программы.exe"
argv[1] → "первый_аргумент"
argv[2] → "второй_аргумент"
...
argv[argc-1] → последний аргумент
argv[argc] → NULL (нулевой указатель)
```
---
#### **Значения элементов**
- **`argv[0]`**  
  Всегда содержит **имя исполняемого файла программы** (например, `"myapp.exe"`).  
  *Пример:*  
  ```cpp
  wcout << L"Программа: " << argv[0]; // Выведет: Программа: C:\myapp.exe
  ```

- **`argv[1]`**  
  **Первый пользовательский аргумент** (если он был передан).  
  *Пример:*  
  ```bash
  myapp.exe file.txt  # argv[1] = "file.txt"
  ```

- **`argv[i]`**  
  **Произвольный аргумент** с индексом `i` (где `0 <= i < argc`).  
  *Пример:*  
  ```cpp
  for(int i = 0; i < argc; i++) {
      wcout << L"Аргумент " << i << ": " << argv[i];
  }
  `
---

## **2. Обработка аргументов командной строки**  
Пример чтения и преобразования аргументов:  
```cpp  
#include <iostream>
#include <sstream>
#include <cstdlib> // для atoi
using namespace std;

int main(int argc, char* argv[]) {
    setlocale(LC_ALL, "Russian");
    wcout << L"Количество аргументов (argc): " << argc << endl;

    for (int i = 0; i < argc; i++) {
        // Вывод аргумента как строки
        wcout << L"Аргумент " << i << ": " << argv[i] << endl;

        // Преобразование в число через stringstream
        stringstream ss;
        ss << argv[i];
        int a;
        if (ss >> a) {
            wcout << L"Число: " << a << endl;
        } else {
            wcout << L"Не число!" << endl;
        }

        // Преобразование через atoi (устаревший метод)
        int num = atoi(argv[i]);
        cout << "atoi: " << num << endl;

        // Создание строки из аргумента
        string str(argv[i]);
        cout << "String: " << str << endl;
    }
    return 0;
}

```  

#### Пояснения:  
- **`stringstream`** — безопасное преобразование строк в числа.  
- **`atoi`** — функция C для преобразования строки в целое число (не рекомендуется из-за отсутствия проверки ошибок).  
- **`string`** — создание объекта строки из C-строки.  

---

## **3. Чтение файла, переданного через аргумент (argv[1])**  
Пример чтения файла, имя которого передано в командной строке:  
```cpp  
#include <iostream>
#include <fstream>
using namespace std;

int main(int argc, char* argv[]) {
    setlocale(LC_ALL, "Russian");

    if (argc < 2) {
        wcout << L"Ошибка: укажите имя файла!" << endl;
        return 1;
    }

    string filename(argv[1]); // argv[1] = имя файла
    ifstream file(filename);

    if (file.is_open()) {
        // Вывод содержимого файла
        cout << file.rdbuf() << endl;
    } else {
        wcout << L"Ошибка открытия файла!" << endl;
    }

    return 0;
}

```  

#### Замечания:  
- **`ifstream`** — класс для чтения файлов.  
- **`file.rdbuf()`** — вывод содержимого файла напрямую в поток.  

---
### Сводка
| **Выражение** | **Тип**       | **Значение**                              |
|---------------|---------------|-------------------------------------------|
| `argv`        | `char* []`    | Массив аргументов                         |
| `argv[0]`     | `const char*` | Имя исполняемого файла                    |
| `argv[1]`     | `const char*` | **Первый переданный аргумент** (если есть) |
| `argv[i]`     | `const char*` | Аргумент с индексом `i` (от `0` до `argc-1`) |
---
---
## **4. Обобщённые функции (шаблоны)**  
**Шаблоны (templates)** — механизм C++, позволяющий создавать обобщённые функции и классы, которые могут работать с различными типами данных.  
**Ключевые преимущества**:
1. Повторное использование кода
2. Типобезопасность (в сравнении с макросами)
3. Избежание дублирования кода
4. Поддержка пользовательских типов

#### Пример 1: Функция `swap_args` - обмен значений 
```cpp  
#include <iostream>
using namespace std;

// Объявление шаблона функции
template <typename T>  // T - параметр типа (placeholder)
void swap_args(T &a, T &b) {
    T temp = a;  // Создаём временную переменную типа T
    a = b;       // Заменяем значение a
    b = temp;    // Восстанавливаем значение b из временной переменной
}

int main() {
    setlocale(LC_ALL, "Russian");
    int x = 5, y = 10;
    wcout << L"До: " << x << " " << y << endl;
    // Вызов шаблонной функции для int
    swap_args(x, y);  // Компилятор автоматически выводит тип T = int
    wcout << L"После: " << x << " " << y << endl;

    // Тест для других типов
    double d1 = 3.14, d2 = 2.71;
    swap_args(d1, d2);  // T = double
    cout << "Double: " << d1 << " " << d2 << endl;

    return 0;
}

```  
**Вывод:**
```
До: 5 10
После: 10 5
Double: 2.71 3.14
```

**Компиляция шаблона**:
   - Компилятор не компилирует шаблон напрямую
   - Генерация кода происходит при первом использовании с конкретным типом
   - Для `swap_args<int>` создаётся специализированная версия функции
   - Для `swap_args<double>` создаётся отдельная версия

---

#### Пример 2: Функция `get_max` - поиск максимального значения 
```cpp  
#include <iostream>
using namespace std;

// Шаблон функции для поиска максимума
template <typename T>
T get_max(const T &a, const T &b) {
    // Используем тернарный оператор для сравнения
    return (a > b) ? a : b;
}

int main() {
    setlocale(LC_ALL, "Russian");
    // Для целых чисел
    int a = 3, b = 7;
    wcout << L"Максимум: " << get_max(a, b) << endl;

    // Для чисел с плавающей точкой
    double c = 2.5, d = 3.8;
    wcout << L"Максимум: " << get_max(c, d) << endl;

    // Для строк (лексикографическое сравнение)
    string s1 = "apple", s2 = "banana";
    cout << "Max string: " << get_max(s1, s2) << endl;

    return 0;
}

```  
**Вывод:**
```
Максимум: 7
Максимум: 3.8
Max string: banana
```

#### Пример 3: Сортировка вектора с использованием стандартной библиотеки
```cpp  
#include <iostream>
#include <vector>
#include <algorithm> // для sort
using namespace std;

int main() {
    setlocale(LC_ALL, "Russian");
    // Создаём вектор целых чисел
    vector<int> v = {9, 8, 7, 6, 5, 4, 3, 2, 1};

    // Вывод до сортировки
    wcout << L"До сортировки: ";
    for (auto num : v) {
        cout << num << " ";
    }

    // Использование шаблонной функции sort
    sort(v.begin(), v.end());  // Обобщённый алгоритм сортировки

    // Вывод после сортировки
    wcout << L"\nПосле сортировки: ";
    for (auto num : v) {
        cout << num << " ";
    }

    return 0;
}

```  
**Вывод:**
```
До сортировки: 9 8 7 6 5 4 3 2 1
После сортировки: 1 2 3 4 5 6 7 8 9
```

## Что надо будет продемонстрировать на зачёте:
- умение открывать и читать файлы
- умение писать циклы
- умение работать со структурами (табличка со структурой файла)
- умение выводить в консоль
- git


# Задание для тренировки:
Задание по работе со структурами данных
Дана файловая запись файловой системы NTFS (File_record.dat), нужно написать программу для извлечения хранящейся в ней информации. Задание имеет несколько уровней сложности, и чем дальше вы сможете зайти, тем лучше. Необходимым минимумом является выполнение первого пункта. Первые три пункта в совокупности по сложности соответствуют заданию на зачет. Выполнение четвертого и пятого пункта наглядно продемонстрирует мне, что вы инициативны и способны самостоятельно осваивать новый материал (преобразование кодировок). Справочный материал, который понадобится вам для выполнения задания, есть в файле Справочный материал NTFS.doc.
 
Задание:
 
1. Разработать структуру (struct), которая описывает первые 0x30 байт заголовка файловой записи (таблица 1). Все целые числа являются беззнаковыми.
 
2. Написать программу, которая при помощи ранее описанной структуры выводит в консоль поля, выделенные в таблице 1 жирным шрифтом.
 
3. Дописать программу таким образом, чтобы она последовательно обходила все атрибуты файловой записи, начиная с первого. Смещение первого атрибута есть в заголовке файловой записи (таблица 1). Каждый атрибут начинается с заголовка длиной 0x18 байт, описанного в таблице 3. Возможные типы атрибутов представлены в таблице 2. Чтобы попасть в следующий атрибут, надо к точке начала текущего атрибута добавить его длину. Атрибуты заканчиваются, когда на месте очередного атрибута (его типа, так как он располагается в самом начале) встречается число 0xFFFFFFFF. Программа должна выводить в консоль типы атрибутов и их имена (по таблице 2).
 
4. Дописать программу, чтобы она выводила в консоль имя файла, которое располагается в атрибуте 0x30. Структура атрибута описана в таблице 4. Имя представлено в кодировке UTF-16LE и может быть напрямую считано в std::wstring.
 
5. Дописать программу, чтобы она выводила содержимое файла, которое располагается в атрибуте 0x80 по "Смещению содержимого атрибута" и имеет "Размер содержимого атрибута" (все в таблице 3). Содержимое файла закодировано в кодировке UTF-8. Для вывода в консоль его надо перекодировать в UTF-16LE с использованием функции MultiByteToWideChar.
 
В качестве результата выполнения первого пункта я хочу увидеть объявленную вами структуру. Выполнение каждого следующего пункта, если вы решили двигаться дальше первого, должно быть зафиксировано соответствующими коммитами. В этом случае я хочу увидеть исходный код программы (в архив не надо упаковывать), а также скриншоты результатов ее работы (вывод в консоль) и лога Git. Если будете создавать репозиторий на GitHub, то делайте его закрытым, а не общедоступным. Чтобы я мог его просмотреть, добавьте меня по адресу электронной почты da.khorkov@urfu.ru (у меня к этому адресу учетная запись GitHub привязана).
 
Внимание! Еще раз повторяю, что необходимым является выполнение только первого пункта. Остальные - по желанию.

 
