# Лекция 7: Передача аргументов из командной строки в программу. Программы и их разбор. Обощенное программирование с использованием функций. Можно ли возращать обобщщенные функции. Что будет на зачёте.

## **1. Работа с аргументами командной строки**  
Аргументы командной строки передаются в программу через параметры `main(int argc, char* argv[])`:  
- **`argc`** — количество аргументов (включая имя программы).  
- **`argv`** — массив строк (аргументы в виде C-строк).  

#### Пример базовой структуры:  
```cpp  
#include <iostream>
using namespace std;

int main(int argc, char* argv[]) { 
    cout << "Hello, World!" << endl;
    return 0;
}
```  

---

## **2. Обработка аргументов командной строки**  
Пример чтения и преобразования аргументов:  
```cpp  
#include <iostream>
#include <sstream>
#include <cstdlib> // для atoi
using namespace std;

int main(int argc, char* argv[]) { 
    setlocale(LC_ALL, "Russian");
    cout << "Количество аргументов (argc): " << argc << endl;

    for (int i = 0; i < argc; i++) {
        // Вывод аргумента как строки
        cout << "Аргумент " << i << ": " << argv[i] << endl;

        // Преобразование в число через stringstream
        stringstream ss;
        ss << argv[i];
        int a;
        if (ss >> a) {
            cout << "Число: " << a << endl;
        } else {
            cout << "Не число!" << endl;
        }

        // Преобразование через atoi (устаревший метод)
        int num = atoi(argv[i]);
        cout << "atoi: " << num << endl;

        // Создание строки из аргумента
        string str(argv[i]);
        cout << "Строка: " << str << endl;
    }
    return 0;
}
```  

#### Пояснения:  
- **`stringstream`** — безопасное преобразование строк в числа.  
- **`atoi`** — функция C для преобразования строки в целое число (не рекомендуется из-за отсутствия проверки ошибок).  
- **`string`** — создание объекта строки из C-строки.  

---

## **3. Чтение файла, переданного через аргумент**  
Пример чтения файла, имя которого передано в командной строке:  
```cpp  
#include <iostream>
#include <fstream>
using namespace std;

int main(int argc, char* argv[]) { 
    setlocale(LC_ALL, "Russian");
    
    if (argc < 2) {
        cerr << "Ошибка: укажите имя файла!" << endl;
        return 1;
    }

    string filename(argv[1]);
    ifstream file(filename);

    if (file.is_open()) {
        // Вывод содержимого файла
        cout << file.rdbuf() << endl;
    } else {
        cerr << "Ошибка открытия файла!" << endl;
    }

    return 0;
}
```  

#### Замечания:  
- **`ifstream`** — класс для чтения файлов.  
- **`file.rdbuf()`** — вывод содержимого файла напрямую в поток.  

---

## **4. Обобщённые функции (шаблоны)**  
**Обобщенная функция** - определяет универсальную совокупность операций, принимаемый к различным типам данных. Это позволяет принмать одну функцию, один алгоритм, к широкому классу типов данных(включая контейнеры, классы, структуры.
Шаблоны позволяют создавать обобщенные функции.  

#### Пример 1: Функция `swap`  
```cpp  
#include <iostream>
using namespace std;

template <typename T>
void swap_args(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    cout << "До: " << x << " " << y << endl;
    swap_args(x, y);
    cout << "После: " << x << " " << y << endl;
    return 0;
}
```  

#### Пример 2: Функция `get_max`  
```cpp  
template <typename T>
T get_max(const T &a, const T &b) {
    return (a > b) ? a : b;
}

int main() {
    int a = 3, b = 7;
    cout << "Максимум: " << get_max(a, b) << endl;

    double c = 2.5, d = 3.8;
    cout << "Максимум: " << get_max(c, d) << endl;
    return 0;
}
```  

#### Пример 3: Сортировка вектора  
```cpp  
#include <vector>
#include <algorithm> // для sort

int main() {
    vector<int> v = {9, 8, 7, 6, 5, 4, 3, 2, 1};
    
    cout << "До сортировки: ";
    for (auto num : v) cout << num << " ";
    
    sort(v.begin(), v.end());
    
    cout << "\nПосле сортировки: ";
    for (auto num : v) cout << num << " ";
    
    return 0;
}
```  

## Что надо будет продемонстрировать на зачёте:
- умение открывать и читать файлы
- умение писать циклы
- умение работать со структурами (табличка со структурой файла)
- умение выводить в консоль
- git


# Задание для тренировки:
Задание по работе со структурами данных
Дана файловая запись файловой системы NTFS (File_record.dat), нужно написать программу для извлечения хранящейся в ней информации. Задание имеет несколько уровней сложности, и чем дальше вы сможете зайти, тем лучше. Необходимым минимумом является выполнение первого пункта. Первые три пункта в совокупности по сложности соответствуют заданию на зачет. Выполнение четвертого и пятого пункта наглядно продемонстрирует мне, что вы инициативны и способны самостоятельно осваивать новый материал (преобразование кодировок). Справочный материал, который понадобится вам для выполнения задания, есть в файле Справочный материал NTFS.doc.
 
Задание:
 
1. Разработать структуру (struct), которая описывает первые 0x30 байт заголовка файловой записи (таблица 1). Все целые числа являются беззнаковыми.
 
2. Написать программу, которая при помощи ранее описанной структуры выводит в консоль поля, выделенные в таблице 1 жирным шрифтом.
 
3. Дописать программу таким образом, чтобы она последовательно обходила все атрибуты файловой записи, начиная с первого. Смещение первого атрибута есть в заголовке файловой записи (таблица 1). Каждый атрибут начинается с заголовка длиной 0x18 байт, описанного в таблице 3. Возможные типы атрибутов представлены в таблице 2. Чтобы попасть в следующий атрибут, надо к точке начала текущего атрибута добавить его длину. Атрибуты заканчиваются, когда на месте очередного атрибута (его типа, так как он располагается в самом начале) встречается число 0xFFFFFFFF. Программа должна выводить в консоль типы атрибутов и их имена (по таблице 2).
 
4. Дописать программу, чтобы она выводила в консоль имя файла, которое располагается в атрибуте 0x30. Структура атрибута описана в таблице 4. Имя представлено в кодировке UTF-16LE и может быть напрямую считано в std::wstring.
 
5. Дописать программу, чтобы она выводила содержимое файла, которое располагается в атрибуте 0x80 по "Смещению содержимого атрибута" и имеет "Размер содержимого атрибута" (все в таблице 3). Содержимое файла закодировано в кодировке UTF-8. Для вывода в консоль его надо перекодировать в UTF-16LE с использованием функции MultiByteToWideChar.
 
В качестве результата выполнения первого пункта я хочу увидеть объявленную вами структуру. Выполнение каждого следующего пункта, если вы решили двигаться дальше первого, должно быть зафиксировано соответствующими коммитами. В этом случае я хочу увидеть исходный код программы (в архив не надо упаковывать), а также скриншоты результатов ее работы (вывод в консоль) и лога Git. Если будете создавать репозиторий на GitHub, то делайте его закрытым, а не общедоступным. Чтобы я мог его просмотреть, добавьте меня по адресу электронной почты da.khorkov@urfu.ru (у меня к этому адресу учетная запись GitHub привязана).
 
Внимание! Еще раз повторяю, что необходимым является выполнение только первого пункта. Остальные - по желанию.

 
