# Лекция 9: Объектно-Ориентированное Программирование (ООП) на C++

## **Введение в ООП**
ООП — это подход к проектированию программ, где основными элементами являются объекты, сочетающие данные и методы для их обработки. 

### **Основные принципы ООП:**
1. **Инкапсуляция**  
   Сокрытие внутренней реализации объекта. Доступ к данным осуществляется через публичные методы.
   
2. **Наследование**  
   Создание иерархии классов. Дочерние классы наследуют свойства и методы родительских.

3. **Полиморфизм**  
   Возможность объектов с одинаковым интерфейсом иметь разную реализацию (например, перегрузка методов).

4. **Абстракция**  
   Упрощение сложных систем путем выделения ключевых характеристик объекта.

5. **Повторное использование кода**  
   Снижение дублирования через наследование и композицию.

### **Ещё немного о ООП**
- ООП состоят из объектов.
- Объект сочетает в себе данные и процедуры для их обработки(методы, операции).
- Объект выполняет операцию(часть программы).
- Отправка запроса - единственный способ выполнить операцию, а выполнение операции - единственный способ изменить внутренние состояние объекта.

---

## **Классы в C++**
Класс — это пользовательский тип данных, определяющий структуру объекта.

### Пример класса `Complex`:
```cpp
#include <iostream>
using namespace std;

class Complex {
private:  // Инкапсуляция: закрытые поля
    double Real;
    double Imaginary;

public:   // Публичный интерфейс
    // Конструктор с параметрами
    Complex(double r, double i);

    // Геттеры (константные методы)
    double R() const;
    double I() const;

    // Методы
    void Print() const;
    void Set(double r, double i);
};

// Реализация конструктора
Complex::Complex(double r, double i){
    Real = r;
    Imaginary = i;
}
// Тоже самое
//Complex::Complex(double r, double i) : Real(r), Imaginary(i) {}

// Реализация метода Print
void Complex::Print() const {
    cout << "C = " << Real << " + " << Imaginary << "i" << endl;
}

// Реализация метода Set
void Complex::Set(double r, double i) {
    Real = r;
    Imaginary = i;
}

int main() {// Статическое создание класса
    //Создание экземляра класса
    Complex myComplexNum(1.0, 1.0);
    cout<< myComplexNum.R() << endl;
    myComplexNum.Print();

    // Динамическое создание класса
    Complex *myComplexPtr = new Complex(2.0, 2.0);
    myComplexPtr->Print();
    delete myComplexPtr;
    return 0;
}
```
Вывод:
```
1
C = 1 + 1i
C = 2 + 2i
```

---

## **Ключевые аспекты реализации**

### 1. **Конструкторы**
- Инициализируют объект при создании.
- **Список инициализации** (`: Real(r), Imaginary(i)`) более эффективен, чем присваивание в теле конструктора.

### 2. **Модификаторы доступа**
- `private`: Доступ только внутри класса.
- `public`: Доступ из любого места программы.

### 3. **Геттеры и методы**
- **Геттеры** (`R()`, `I()`) предоставляют доступ к приватным полям.
- **Константные методы** (например, `Print() const`) гарантируют, что метод не изменяет состояние объекта.
---

## **Создание объектов**
### Статическое создание:
```cpp
Complex myComplexNum1(1.0, 1.0);        // (1) Прямая инициализация
Complex myComplexNum2(3.0, 3.0);        // (2) Прямая инициализация
myComplexNum2 = myComplexNum1;          // (3) Присваивание (operator=)
Complex myComplexNum3(myComplexNum2);   // (4) Конструктор копирования
Complex myComplexNum4 = myComplexNum3;  // (5) Копирующая инициализация
```
---
### **Ключевые различия**

| Сценарий             | Когда вызывается?           | Что происходит?                  |
|----------------------|-----------------------------|-----------------------------------|
| Прямая инициализация | Создание нового объекта     | Вызов обычного конструктора      |
| Присваивание (`=`)   | Для существующих объектов   | Вызов `operator=`                |
| Конструктор копирования | Создание нового объекта  | Копирование полей исходного объекта |
| Копирующая инициализация | Создание нового объекта | Синтаксический сахар для конструктора копирования |

---
Код:
```cpp
#include <iostream>
using namespace std;

class Complex {
private:  // Закрытая часть (инкапсуляция)
    double Real;
    double Imaginary;

public:   // Публичные методы
    Complex(double r, double i);
    // Геттеры
    double R() const { return Real; }
    double I() const { return Imaginary; }

    // Операторы для работы с комплексной части:

    // Метод вывода
    void Print() const;
    // Задание значеия
    void Set(double r, double i);
};

//Конструктор
Complex::Complex(double r, double i){//реализация конструктора
    Real = r;
    Imaginary = i;
}

void Complex::Print() const
{
    cout << "C = "<< Real << " + " << Imaginary << "i" << endl;
}
void Complex::Set(double r, double i)
{
    Real = r;
    Imaginary = i;
}

int main(){
    Complex myComplexNum1(1.0, 1.0);
    Complex myComplexNum2(3.0, 3.0);
    myComplexNum2 = myComplexNum1;
    myComplexNum2.Print(); //C = 1 + 1i

    Complex myComplexNum3(myComplexNum2);
    myComplexNum3.Print(); //C = 1 + 1i

    Complex myComplexNum4 = myComplexNum3;
    myComplexNum4.Print();//C = 1 + 1i (но также может вывести, что захочет)
    return 0;
};
```
---

## **Операторы для работы с комплексными числами("+", "=")**
- **Оператор присваивания** копирует значения полей одного объекта в другой.
- **Оператор сложения** складывает значения полей одного объекта с другим.
Для этого надо сделать перегрузка операторов (+) и (=)

Добавили:
```cpp
    Complex& operator +(const Complex &x)
    {
        Real += x.Real;
        Imaginary += x.Imaginary;
        return *this;
    }
    Complex& operator =(const Complex &x)
    {
        Set(x.R(), x.I());
        cout << "operator =" << endl;
        return *this;
    }
```
---
Код:
```cpp
#include <iostream>
using namespace std;

class Complex {
private:  // Закрытая часть (инкапсуляция)
    double Real;
    double Imaginary;

public:   // Публичные методы
    Complex(double r, double i);
    // Геттеры
    double R() const { return Real; }
    double I() const { return Imaginary; }

    // Операторы для работы с комплексной части:

    // Метод вывода
    void Print() const;
    // Задание значеия
    void Set(double r, double i);

    Complex& operator +(const Complex &x)
    {
        Real += x.Real;
        Imaginary += x.Imaginary;
        return *this;
    }
    Complex& operator =(const Complex &x)
    {
        Set(x.R(), x.I());
        return *this;
    }
};

//Конструктор
Complex::Complex(double r, double i){//реализация конструктора
    Real = r;
    Imaginary = i;
}

void Complex::Print() const
{
    cout << "C = "<< Real << " + " << Imaginary << "i" << endl;
}
void Complex::Set(double r, double i)
{
    Real = r;
    Imaginary = i;
}


int main(){
    Complex myComplexNum1(1.0, 1.0);
    Complex myComplexNum2(3.0, 3.0);
    myComplexNum1 = myComplexNum1 + myComplexNum2;
    myComplexNum1.Print();
    return 0;
};
```
Вывод:
```
C = 4 + 4i
```
---

## **Интерфейс класса**
Интерфейс — это публичные методы, через которые взаимодействуют с объектом. Он скрывает внутреннюю реализацию и обеспечивает:
- **Абстракцию**: Работа на уровне "что делает объект", а не "как".
- **Инкапсуляцию**: Защита данных от некорректного доступа.

---

## **Советы по написанию кода**
1. Всегда инициализируйте поля в конструкторе.
2. Используйте `const` для методов, которые не меняют состояние объекта.
3. Перегружайте операторы осмысленно (например, `+` для сложения, а не для вычитания).
4. Управляйте динамической памятью: для каждого `new` должен быть `delete`.

---

## **Рекомендуемая литература:**  
- "Совершенный код" С. Макконнел — лучшие практики программирования.  
- "Паттерны проектирования" Э. Гамма — архитектурные шаблоны.  
- cppreference.com — онлайн справочник по C++.
- C++: Полный справочник (Шмидт, Прата).

## Задание:
1. Придумать уникальное семейство объектов, с которыми вы будете работать. Повторов быть не должно, поэтому отписываемся в общем чате, кто что выбрал. А когда выбираем, то смотрим, что выбрали другие. Жизнь на Земле разнообразная, техники всякой существует почти бесконечное количество, поэтому требование уникальности выбранного семейства выполнимое.
2. Разработать систему классов для выбранного семейства с одним базовым классом и необходимым количеством унаследованных от него (не менее 3 наследников).
3. Придумать атрибуты объектов в количестве не менее 4. Часть будут общими, часть могут быть характерными для классов-наследников. Реализовать атрибуты в виде свойств (членов-данных) классов.
4. Придумать общие действия, которые можно выполнять над объектами (не менее 3). Реализовать действия в виде виртуальных методов классов. В зависимости от конкретного класса-наследника методы должны отличаться.
5. Написать программу, демонстрирующую использование семейства объектов, в том числе полиморфизм.
